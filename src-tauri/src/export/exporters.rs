use crate::LevelData;
use crate::spatial::BoundingBox;
use crate::export::ExportFormat;
use anyhow::{Result, anyhow};
use log::{info, warn};
use serde_json;
use std::fs;
use std::path::{Path, PathBuf};

pub struct LevelExporter;

impl LevelExporter {
    pub fn new() -> Self {
        Self
    }
    
    pub async fn export_multi_format(
        &self,
        level_data: &LevelData,
        formats: &[ExportFormat],
        output_path: &str,
    ) -> Result<Vec<String>> {
        let base_path = Path::new(output_path);
        let mut exported_files = Vec::new();
        
        // Ensure output directory exists
        if let Some(parent) = base_path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        for format in formats {
            let file_path = self.get_export_file_path(base_path, format)?;
            
            match format {
                ExportFormat::JSON => {
                    self.export_json(level_data, &file_path).await?;
                }
                ExportFormat::RON => {
                    self.export_ron(level_data, &file_path).await?;
                }
                ExportFormat::RustCode => {
                    self.export_rust_code(level_data, &file_path).await?;
                }
                ExportFormat::GLTF => {
                    warn!("GLTF export not yet implemented");
                    continue;
                }
                ExportFormat::FBX => {
                    warn!("FBX export not yet implemented");
                    continue;
                }
            }
            
            exported_files.push(file_path.to_string_lossy().to_string());
            info!("Exported to: {:?}", file_path);
        }
        
        Ok(exported_files)
    }
    
    fn get_export_file_path(&self, base_path: &Path, format: &ExportFormat) -> Result<PathBuf> {
        let base_name = base_path
            .file_stem()
            .ok_or_else(|| anyhow!("Invalid base path"))?
            .to_string_lossy();
            
        let parent = base_path
            .parent()
            .unwrap_or_else(|| Path::new("."));
            
        let file_name = format!("{}.{}", base_name, format.file_extension());
        Ok(parent.join(file_name))
    }
    
    async fn export_json(&self, level_data: &LevelData, file_path: &PathBuf) -> Result<()> {
        let json_data = serde_json::to_string_pretty(level_data)?;
        fs::write(file_path, json_data)?;
        Ok(())
    }
    
    async fn export_ron(&self, level_data: &LevelData, file_path: &PathBuf) -> Result<()> {
        // Convert to Bevy-compatible RON format
        let bevy_level = self.convert_to_bevy_format(level_data)?;
        let ron_data = ron::ser::to_string_pretty(&bevy_level, ron::ser::PrettyConfig::default())?;
        fs::write(file_path, ron_data)?;
        Ok(())
    }
    
    async fn export_rust_code(&self, level_data: &LevelData, file_path: &PathBuf) -> Result<()> {
        let rust_code = self.generate_rust_code(level_data)?;
        fs::write(file_path, rust_code)?;
        Ok(())
    }
    
    fn convert_to_bevy_format(&self, level_data: &LevelData) -> Result<BevyLevelData> {
        let mut bevy_entities = Vec::new();
        
        for obj in &level_data.objects {
            bevy_entities.push(BevyEntity {
                name: obj.name.clone(),
                transform: BevyTransform {
                    translation: obj.transform.position,
                    rotation: obj.transform.rotation,
                    scale: obj.transform.scale,
                },
                mesh: obj.mesh.clone(),
                material: obj.material.clone(),
                layer: obj.layer.clone(),
                tags: obj.tags.clone(),
            });
        }
        
        Ok(BevyLevelData {
            name: level_data.name.clone(),
            entities: bevy_entities,
            bounds: level_data.bounds.clone(),
            metadata: BevyMetadata {
                generation_seed: level_data.generation_seed,
                generator: "BSP".to_string(),
                version: "0.1.0".to_string(),
            },
        })
    }
    
    fn generate_rust_code(&self, level_data: &LevelData) -> Result<String> {
        let mut code = String::new();
        
        // File header
        code.push_str("// Generated level code for Bevy\n");
        code.push_str("// This file was auto-generated by Morgan-Bevy Level Editor\n\n");
        code.push_str("use bevy::prelude::*;\n");
        code.push_str("use bevy::asset::Handle;\n\n");
        
        // Function signature
        code.push_str(&format!(
            "pub fn spawn_level_{}(commands: &mut Commands, asset_server: &Res<AssetServer>) {{\n",
            level_data.name.to_lowercase().replace(' ', "_")
        ));
        
        // Spawn each object
        for obj in &level_data.objects {
            code.push_str(&format!(
                "    // {}\n    commands.spawn((\n",
                obj.name
            ));
            
            // Transform component
            code.push_str(&format!(
                "        Transform::from_translation(Vec3::new({:.2}, {:.2}, {:.2}))\n",
                obj.transform.position[0], obj.transform.position[1], obj.transform.position[2]
            ));
            code.push_str(&format!(
                "            .with_rotation(Quat::from_xyzw({:.4}, {:.4}, {:.4}, {:.4}))\n",
                obj.transform.rotation[0], obj.transform.rotation[1], 
                obj.transform.rotation[2], obj.transform.rotation[3]
            ));
            code.push_str(&format!(
                "            .with_scale(Vec3::new({:.2}, {:.2}, {:.2})),\n",
                obj.transform.scale[0], obj.transform.scale[1], obj.transform.scale[2]
            ));
            
            // Mesh component
            if let Some(ref mesh) = obj.mesh {
                code.push_str(&format!(
                    "        PbrBundle {{\n            mesh: asset_server.load(\"{}\"),\n",
                    mesh
                ));
                
                // Material component
                if let Some(ref material) = obj.material {
                    code.push_str(&format!(
                        "            material: asset_server.load(\"{}\"),\n",
                        material
                    ));
                } else {
                    code.push_str("            material: asset_server.load(\"materials/default.mat\"),\n");
                }
                
                code.push_str("            ..default()\n        },\n");
            }
            
            // Name component
            code.push_str(&format!(
                "        Name::new(\"{}\"),\n",
                obj.name
            ));
            
            // Tags/layers as custom components could be added here
            for tag in &obj.tags {
                code.push_str(&format!(
                    "        // Tag: {}\n",
                    tag
                ));
            }
            
            code.push_str("    ));\n\n");
        }
        
        // Function footer
        code.push_str("}\n\n");
        
        // Add convenience function for level bounds
        code.push_str(&format!(
            "pub fn get_level_{}_bounds() -> (Vec3, Vec3) {{\n",
            level_data.name.to_lowercase().replace(' ', "_")
        ));
        code.push_str(&format!(
            "    (Vec3::new({:.2}, {:.2}, {:.2}), Vec3::new({:.2}, {:.2}, {:.2}))\n",
            level_data.bounds.min[0], level_data.bounds.min[1], level_data.bounds.min[2],
            level_data.bounds.max[0], level_data.bounds.max[1], level_data.bounds.max[2]
        ));
        code.push_str("}\n");
        
        Ok(code)
    }
}

// Bevy-specific data structures for RON export
#[derive(serde::Serialize)]
struct BevyLevelData {
    name: String,
    entities: Vec<BevyEntity>,
    bounds: BoundingBox,
    metadata: BevyMetadata,
}

#[derive(serde::Serialize)]
struct BevyEntity {
    name: String,
    transform: BevyTransform,
    mesh: Option<String>,
    material: Option<String>,
    layer: String,
    tags: Vec<String>,
}

#[derive(serde::Serialize)]
struct BevyTransform {
    translation: [f32; 3],
    rotation: [f32; 4],
    scale: [f32; 3],
}

#[derive(serde::Serialize)]
struct BevyMetadata {
    generation_seed: Option<u64>,
    generator: String,
    version: String,
}